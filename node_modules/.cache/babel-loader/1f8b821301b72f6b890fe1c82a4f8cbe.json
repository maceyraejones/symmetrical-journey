{"ast":null,"code":"import FontFaceObserver from \"fontfaceobserver\";\nconst FONT_LOADING_TIMEOUT = 5000; // Amount of ms to wait when detecting if a font is ready\n\nconst MAX_RETRIES = 3; // Max number of times to retry font loading in case network error occurs\n\nexport class FontLoadingError extends Error {\n  constructor(message) {\n    super(message);\n    this.name = \"FontLoadingError\";\n  }\n\n}\nconst fontRequests = new Map();\nconst fontReadyPromises = new Map();\n/** @internal  */\n\nexport const loadFont = (data, doc) => loadFontWithRetries(data, doc);\n\nasync function loadFontWithRetries(data, doc) {\n  let attempt = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  const {\n    family,\n    url\n  } = data;\n  const weight = data.weight || 500;\n  const style = data.style || \"normal\";\n  const requestId = `${family}-${style}-${weight}-${url}`;\n\n  if (!fontRequests.has(requestId) || attempt > 0) {\n    const fontFace = new FontFace(family, `url(${url})`, {\n      weight: weight?.toString(),\n      style\n    });\n    const readyPromise = fontFace // Load the font\n    .load().then(() => {\n      // Add the font to the document\n      doc.fonts.add(fontFace); // Wait until it's fully ready\n\n      return isFontReady(family, style, weight);\n    }).catch(e => {\n      if (e.name !== \"NetworkError\") {\n        throw e;\n      } // In case of a network error; retry\n\n\n      if (attempt < MAX_RETRIES) {\n        return loadFontWithRetries(data, doc, attempt + 1);\n      } // Throw error when retry limit has been reached\n\n\n      throw new FontLoadingError(`Font loading failed after ${attempt} retries due to network error: ${JSON.stringify({\n        family,\n        style,\n        weight,\n        url\n      })}`);\n    });\n    fontRequests.set(requestId, readyPromise);\n  }\n\n  await fontRequests.get(requestId);\n}\n/** @internal  */\n\n\nexport async function isFontReady(family, style, weight) {\n  const readyPromiseId = `${family}-${style}-${weight}`;\n\n  if (!fontReadyPromises.has(readyPromiseId)) {\n    const observer = new FontFaceObserver(family, {\n      style,\n      weight\n    });\n    const readyPromise = observer.load(null, FONT_LOADING_TIMEOUT);\n    fontReadyPromises.set(readyPromiseId, readyPromise);\n  }\n\n  try {\n    await fontReadyPromises.get(readyPromiseId);\n  } catch (e) {\n    throw new FontLoadingError(`Failed to check if font is ready (${FONT_LOADING_TIMEOUT}ms timeout exceeded): ${JSON.stringify({\n      family,\n      style,\n      weight\n    })}`);\n  }\n}\n/**\n * @internal\n * Util function for use in tests to clear state between test cases\n * */\n\nexport function _clearCache() {\n  fontRequests.clear();\n  fontReadyPromises.clear();\n}","map":{"version":3,"mappings":"AAAA,OAAOA,gBAAP,MAA6B,kBAA7B;AAEA,MAAMC,oBAAoB,GAAG,IAA7B,C,CAAkC;;AAClC,MAAMC,WAAW,GAAG,CAApB,C,CAAsB;;AAEtB,OAAM,MAAOC,gBAAP,SAAgCC,KAAhC,CAAqC;AACvCC,cAAYC,OAAZ,EAA2B;AACvB,UAAMA,OAAN;AACA,SAAKC,IAAL,GAAY,kBAAZ;AACH;;AAJsC;AAO3C,MAAMC,YAAY,GAAG,IAAIC,GAAJ,EAArB;AACA,MAAMC,iBAAiB,GAAG,IAAID,GAAJ,EAA1B;AASA;;AACA,OAAO,MAAME,QAAQ,GAAG,CAACC,IAAD,EAAqBC,GAArB,KAAsDC,mBAAmB,CAACF,IAAD,EAAOC,GAAP,CAA1F;;AAEP,eAAeC,mBAAf,CAAmCF,IAAnC,EAAuDC,GAAvD,EAAiF;AAAA,MAAXE,OAAW,uEAAD,CAAC;AAC7E,QAAM;AAAEC,UAAF;AAAUC;AAAV,MAAkBL,IAAxB;AACA,QAAMM,MAAM,GAAGN,IAAI,CAACM,MAAL,IAAe,GAA9B;AACA,QAAMC,KAAK,GAAGP,IAAI,CAACO,KAAL,IAAc,QAA5B;AAEA,QAAMC,SAAS,GAAG,GAAGJ,MAAM,IAAIG,KAAK,IAAID,MAAM,IAAID,GAAG,EAArD;;AACA,MAAI,CAACT,YAAY,CAACa,GAAb,CAAiBD,SAAjB,CAAD,IAAgCL,OAAO,GAAG,CAA9C,EAAiD;AAC7C,UAAMO,QAAQ,GAAG,IAAIC,QAAJ,CAAaP,MAAb,EAAqB,OAAOC,GAAG,GAA/B,EAAoC;AACjDC,YAAM,EAAEA,MAAM,EAAEM,QAAR,EADyC;AAEjDL;AAFiD,KAApC,CAAjB;AAIA,UAAMM,YAAY,GAAGH,QAAQ,CACzB;AADyB,KAExBI,IAFgB,GAGhBC,IAHgB,CAGX,MAAK;AACP;AACAd,SAAG,CAACe,KAAJ,CAAUC,GAAV,CAAcP,QAAd,EAFO,CAGP;;AACA,aAAOQ,WAAW,CAACd,MAAD,EAASG,KAAT,EAAgBD,MAAhB,CAAlB;AACH,KARgB,EAShBa,KATgB,CASVC,CAAC,IAAG;AACP,UAAIA,CAAC,CAACzB,IAAF,KAAW,cAAf,EAA+B;AAC3B,cAAMyB,CAAN;AACH,OAHM,CAIP;;;AACA,UAAIjB,OAAO,GAAGb,WAAd,EAA2B;AACvB,eAAOY,mBAAmB,CAACF,IAAD,EAAOC,GAAP,EAAYE,OAAO,GAAG,CAAtB,CAA1B;AACH,OAPM,CAQP;;;AACA,YAAM,IAAIZ,gBAAJ,CACF,6BAA6BY,OAAO,kCAAkCkB,IAAI,CAACC,SAAL,CAAe;AACjFlB,cADiF;AAEjFG,aAFiF;AAGjFD,cAHiF;AAIjFD;AAJiF,OAAf,CAKpE,EANA,CAAN;AAQH,KA1BgB,CAArB;AA2BAT,gBAAY,CAAC2B,GAAb,CAAiBf,SAAjB,EAA4BK,YAA5B;AACH;;AACD,QAAMjB,YAAY,CAAC4B,GAAb,CAAiBhB,SAAjB,CAAN;AACH;AAED;;;AACA,OAAO,eAAeU,WAAf,CACHd,MADG,EAEHG,KAFG,EAGHD,MAHG,EAGuB;AAE1B,QAAMmB,cAAc,GAAG,GAAGrB,MAAM,IAAIG,KAAK,IAAID,MAAM,EAAnD;;AACA,MAAI,CAACR,iBAAiB,CAACW,GAAlB,CAAsBgB,cAAtB,CAAL,EAA4C;AACxC,UAAMC,QAAQ,GAAG,IAAItC,gBAAJ,CAAqBgB,MAArB,EAA6B;AAC1CG,WAD0C;AAE1CD;AAF0C,KAA7B,CAAjB;AAIA,UAAMO,YAAY,GAAGa,QAAQ,CAACZ,IAAT,CAAc,IAAd,EAAoBzB,oBAApB,CAArB;AACAS,qBAAiB,CAACyB,GAAlB,CAAsBE,cAAtB,EAAsCZ,YAAtC;AACH;;AACD,MAAI;AACA,UAAMf,iBAAiB,CAAC0B,GAAlB,CAAsBC,cAAtB,CAAN;AACH,GAFD,CAEE,OAAOL,CAAP,EAAU;AACR,UAAM,IAAI7B,gBAAJ,CACF,qCAAqCF,oBAAoB,yBAAyBgC,IAAI,CAACC,SAAL,CAAe;AAC7FlB,YAD6F;AAE7FG,WAF6F;AAG7FD;AAH6F,KAAf,CAIhF,EALA,CAAN;AAOH;AACJ;AAED;;;;;AAIA,OAAM,SAAUqB,WAAV,GAAqB;AACvB/B,cAAY,CAACgC,KAAb;AACA9B,mBAAiB,CAAC8B,KAAlB;AACH","names":["FontFaceObserver","FONT_LOADING_TIMEOUT","MAX_RETRIES","FontLoadingError","Error","constructor","message","name","fontRequests","Map","fontReadyPromises","loadFont","data","doc","loadFontWithRetries","attempt","family","url","weight","style","requestId","has","fontFace","FontFace","toString","readyPromise","load","then","fonts","add","isFontReady","catch","e","JSON","stringify","set","get","readyPromiseId","observer","_clearCache","clear"],"sources":["../../../src/render/fonts/loadFont.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"module"}