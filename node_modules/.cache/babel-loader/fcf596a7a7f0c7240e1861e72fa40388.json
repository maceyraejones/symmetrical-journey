{"ast":null,"code":"// We disable the rule of hooks because we early return when not in the preview\n// or on a touch device. This early return will be constistent per environment.\n\n/* eslint-disable react-hooks/rules-of-hooks */\nimport React, { useEffect } from \"react\";\nimport { isSafari, isTouch } from \"../../utils/environment.js\";\nimport { RenderTarget } from \"../../render/types/RenderEnvironment.js\";\nimport { Point } from \"../../render/types/Point.js\";\nimport { animatePointWithInertia } from \"./animatePointWithInertia.js\";\nconst scrollThreshold = 3;\nconst isTouchDevice = isTouch();\nconst isSafariBrowser = isSafari();\n\nfunction getTouchAction(element) {\n  if (!(element instanceof HTMLElement)) return null;\n  return element.style.touchAction;\n}\n\nfunction canPanInDirection(element, direction) {\n  switch (direction) {\n    case \"horizontal\":\n      return getTouchAction(element) === \"pan-x\";\n\n    case \"vertical\":\n      return getTouchAction(element) === \"pan-y\";\n\n    default:\n      return false;\n  }\n}\n\nfunction isInteractiveElement(element) {\n  const tag = element.tagName.toLowerCase();\n  if (tag === \"input\") return true;\n  if (tag === \"text\") return true;\n  if (tag === \"textarea\") return true;\n  return false;\n}\n\nfunction canStartScrollFromElement(element, direction) {\n  if (!(element instanceof Element)) return false;\n  if (isInteractiveElement(element)) return false;\n\n  if (element.hasAttribute(\"draggable\")) {\n    if (!canPanInDirection(element, direction)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction getEventPoint(event) {\n  return {\n    x: event.pageX,\n    y: event.pageY\n  };\n}\n\nfunction setStyle(element, property, value) {\n  if (element?.style) {\n    element.style[property] = value;\n  }\n}\n\nfunction getStyle(element, property) {\n  return element?.style?.[property];\n}\n\nvar TouchScrollPhase;\n\n(function (TouchScrollPhase) {\n  TouchScrollPhase[TouchScrollPhase[\"Idle\"] = 0] = \"Idle\";\n  TouchScrollPhase[TouchScrollPhase[\"TouchDown\"] = 1] = \"TouchDown\";\n  TouchScrollPhase[TouchScrollPhase[\"Drag\"] = 2] = \"Drag\";\n  TouchScrollPhase[TouchScrollPhase[\"DragLocked\"] = 3] = \"DragLocked\";\n  TouchScrollPhase[TouchScrollPhase[\"DragAnimation\"] = 4] = \"DragAnimation\";\n  TouchScrollPhase[TouchScrollPhase[\"Interrupted\"] = 5] = \"Interrupted\";\n})(TouchScrollPhase || (TouchScrollPhase = {}));\n\nconst emptyObject = {};\nObject.freeze(emptyObject);\nexport function useEmulateTouchScroll(ref, direction, enabled) {\n  if (isTouchDevice) return emptyObject;\n  if (RenderTarget.current() !== RenderTarget.preview) return emptyObject;\n  const scrollAnimationControlsRef = React.useRef(null);\n  useEffect(() => {\n    if (!ref.current) return;\n    const element = ref.current;\n    let phase = TouchScrollPhase.Idle;\n    let targets = null;\n    let downPoint = null;\n    let scrollOffsetStart = null;\n    let mouseMoveEvents = [];\n\n    function onMouseMove(event) {\n      switch (phase) {\n        case TouchScrollPhase.Idle:\n        case TouchScrollPhase.DragAnimation:\n        case TouchScrollPhase.DragLocked:\n          return;\n      } // If command is pressed we fallback to normal behavior\n\n\n      if (event.metaKey) return;\n      const point = getEventPoint(event);\n      if (!downPoint) return; // Calculate the offset so we can use it in the callback\n\n      const offset = Point.subtract(point, downPoint); // If we didn't scroll before and reached the threshold\n\n      if (phase === TouchScrollPhase.TouchDown || phase === TouchScrollPhase.Interrupted) {\n        const deltaX = Math.abs(offset.x);\n        const deltaY = Math.abs(offset.y);\n\n        if ((deltaX > scrollThreshold || deltaY > scrollThreshold) && deltaX !== deltaY) {\n          const scrollDirection = deltaX > deltaY ? \"horizontal\" : \"vertical\";\n          const shouldIgnoreBecauseOfDirectionLock = direction === \"horizontal\" && scrollDirection === \"vertical\" || direction === \"vertical\" && scrollDirection === \"horizontal\";\n\n          if (shouldIgnoreBecauseOfDirectionLock) {\n            phase = TouchScrollPhase.DragLocked;\n            return;\n          }\n\n          phase = TouchScrollPhase.Drag; // We disable events on the clicked target so we avoid clicks if you mean to scroll\n\n          targets?.forEach(_ref => {\n            let [target] = _ref;\n            return setStyle(target, \"pointerEvents\", \"none\");\n          });\n        }\n      } // We need this in Safari to avoid scroll from text selection near borders\n      // Unfortunately we'll have to do this for all events and this could break\n      // in subtle ways.\n\n\n      if (isSafariBrowser) event.preventDefault(); // Don't do anything if we didn't reach the threshold\n\n      if (phase !== TouchScrollPhase.Drag) return; // Don't start selecting text too\n\n      window.getSelection()?.empty();\n      mouseMoveEvents = getRecentEvents([...mouseMoveEvents, event]); // Update offset\n\n      if (scrollOffsetStart) {\n        if (direction !== \"vertical\") element.scrollLeft = scrollOffsetStart.x - offset.x;\n        if (direction !== \"horizontal\") element.scrollTop = scrollOffsetStart.y - offset.y;\n      }\n    }\n\n    function onMouseUp(event) {\n      window.removeEventListener(\"mousemove\", onMouseMove, false);\n      window.removeEventListener(\"mouseup\", onMouseUp); // Make sure to restore events back on the element if we removed them\n\n      if (phase === TouchScrollPhase.Drag && targets) {\n        targets.forEach(_ref2 => {\n          let [target, originalPointerEventsValue] = _ref2;\n          return setStyle(target, \"pointerEvents\", originalPointerEventsValue || \"auto\");\n        });\n      }\n\n      targets = null;\n      const velocity = calculateVelocity({\n        mouseMoveEvents,\n        mouseUpEvent: event\n      });\n      downPoint = null;\n\n      if (phase === TouchScrollPhase.Drag) {\n        // Scroll\n        // Unlike page snapping we only have to animate the scroll if we started a drag\n        const shouldAnimateY = direction !== \"horizontal\" && velocity.y !== 0;\n        const shouldAnimateX = direction !== \"vertical\" && velocity.x !== 0;\n\n        if (!shouldAnimateY && !shouldAnimateX) {\n          phase = TouchScrollPhase.Idle;\n          return;\n        }\n\n        phase = TouchScrollPhase.DragAnimation;\n        scrollAnimationControlsRef.current = animatePointWithInertia({\n          from: {\n            x: element.scrollLeft,\n            y: element.scrollTop\n          },\n          velocity: {\n            x: shouldAnimateX ? velocity.x : 0,\n            y: shouldAnimateY ? velocity.y : 0\n          },\n          onUpdate: position => {\n            if (shouldAnimateX) element.scrollLeft = position.x;\n            if (shouldAnimateY) element.scrollTop = position.y;\n          },\n          onStop: () => {\n            if (phase !== TouchScrollPhase.Interrupted) {\n              phase = TouchScrollPhase.Idle;\n            }\n\n            scrollAnimationControlsRef.current = null;\n          },\n          onComplete: () => {\n            if (phase !== TouchScrollPhase.DragAnimation) {\n              throw Error(\"On animation completion we should still be in the animation phase\");\n            }\n\n            phase = TouchScrollPhase.Idle;\n            scrollAnimationControlsRef.current = null;\n          }\n        });\n      } else {\n        phase = TouchScrollPhase.Idle;\n      }\n    }\n\n    function onMouseWheel() {\n      // Stop any running animations when using mouse wheel or trackpad\n      scrollAnimationControlsRef.current?.stop();\n    }\n\n    function onMouseDown(event) {\n      if (!enabled) return; // If command or control was entered we fallback to normal behavior\n\n      if (event.metaKey) return;\n\n      if (!canStartScrollFromElement(event.target, direction)) {\n        // Stop any running scroll animation\n        if (phase === TouchScrollPhase.DragAnimation) {\n          phase = TouchScrollPhase.Idle;\n          scrollAnimationControlsRef.current?.stop();\n        }\n\n        return;\n      }\n\n      const previousPhase = phase;\n      phase = previousPhase === TouchScrollPhase.DragAnimation ? TouchScrollPhase.Interrupted : TouchScrollPhase.TouchDown;\n      downPoint = getEventPoint(event);\n      targets = document.elementsFromPoint(downPoint.x, downPoint.y).filter(targetEl => targetEl instanceof HTMLElement || targetEl instanceof SVGElement).map(targetEl => [targetEl, getStyle(targetEl, \"pointerEvents\")]);\n      scrollOffsetStart = {\n        x: element.scrollLeft,\n        y: element.scrollTop\n      };\n      mouseMoveEvents = [];\n\n      if (scrollAnimationControlsRef.current) {\n        if (previousPhase !== TouchScrollPhase.DragAnimation) {\n          throw Error(\"When stopping a drag animation we need to be animating\");\n        }\n\n        scrollAnimationControlsRef.current.stop();\n      }\n\n      window.addEventListener(\"mousemove\", onMouseMove);\n      window.addEventListener(\"mouseup\", onMouseUp);\n      element.addEventListener(\"mousewheel\", onMouseWheel);\n    } // Set up a the base handler on the scrollable element\n\n\n    element.addEventListener(\"mousedown\", onMouseDown);\n    return () => {\n      // Clean up all event handlers on unmount\n      element.removeEventListener(\"mousedown\", onMouseDown);\n      element.removeEventListener(\"mousewheel\", onMouseWheel);\n      window.removeEventListener(\"mousemove\", onMouseMove);\n      window.removeEventListener(\"mouseup\", onMouseUp); // Stop any running scroll animations\n\n      phase = TouchScrollPhase.Interrupted;\n      scrollAnimationControlsRef.current?.stop();\n    };\n  }, [ref, direction, enabled]);\n  return React.useMemo(() => {\n    return {\n      cancelEmulatedTouchScrollAnimation: () => {\n        scrollAnimationControlsRef.current?.stop();\n      }\n    };\n  }, []);\n} // Keep events that are younger than 4 / 60 s\n\nconst timeDelta = 4 / 60 * 1000;\n\nfunction getRecentEvents(events) {\n  // There is no API to get the time origin of event timestamps, as a workaround\n  // we create a custom event and read the timestamp\n  const currentTime = new CustomEvent(\"getTime\").timeStamp;\n  const maxAge = currentTime - timeDelta;\n  return events.filter(event => event.timeStamp > maxAge);\n}\n\nconst zeroPoint = {\n  x: 0,\n  y: 0\n};\nexport function calculateVelocity(_ref3) {\n  let {\n    mouseMoveEvents,\n    mouseUpEvent\n  } = _ref3;\n  const recentMouseMoveEvents = getRecentEvents(mouseMoveEvents);\n  const oldestMouseMoveEvent = recentMouseMoveEvents[0];\n  if (!oldestMouseMoveEvent) return zeroPoint;\n  const deltaX = mouseUpEvent.clientX - oldestMouseMoveEvent.clientX;\n  const deltaY = mouseUpEvent.clientY - oldestMouseMoveEvent.clientY;\n  const time = mouseUpEvent.timeStamp - oldestMouseMoveEvent.timeStamp;\n  if (time === 0) return zeroPoint;\n  return {\n    x: deltaX / time * 1000,\n    y: deltaY / time * 1000\n  };\n}","map":{"version":3,"mappings":"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","names":["React","useEffect","isSafari","isTouch","RenderTarget","Point","animatePointWithInertia","scrollThreshold","isTouchDevice","isSafariBrowser","getTouchAction","element","HTMLElement","style","touchAction","canPanInDirection","direction","isInteractiveElement","tag","tagName","toLowerCase","canStartScrollFromElement","Element","hasAttribute","getEventPoint","event","x","pageX","y","pageY","setStyle","property","value","getStyle","TouchScrollPhase","emptyObject","Object","freeze","useEmulateTouchScroll","ref","enabled","current","preview","scrollAnimationControlsRef","useRef","phase","Idle","targets","downPoint","scrollOffsetStart","mouseMoveEvents","onMouseMove","DragAnimation","DragLocked","metaKey","point","offset","subtract","TouchDown","Interrupted","deltaX","Math","abs","deltaY","scrollDirection","shouldIgnoreBecauseOfDirectionLock","Drag","forEach","target","preventDefault","window","getSelection","empty","getRecentEvents","scrollLeft","scrollTop","onMouseUp","removeEventListener","originalPointerEventsValue","velocity","calculateVelocity","mouseUpEvent","shouldAnimateY","shouldAnimateX","from","onUpdate","position","onStop","onComplete","Error","onMouseWheel","stop","onMouseDown","previousPhase","document","elementsFromPoint","filter","targetEl","SVGElement","map","addEventListener","useMemo","cancelEmulatedTouchScrollAnimation","timeDelta","events","currentTime","CustomEvent","timeStamp","maxAge","zeroPoint","recentMouseMoveEvents","oldestMouseMoveEvent","clientX","clientY","time"],"sources":["../../../src/components/utils/useEmulatedTouchScroll.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"module"}