{"ast":null,"code":"import sync from \"framesync\";\nimport { inertia } from \"popmotion\";\nvar AnimationPhase;\n\n(function (AnimationPhase) {\n  AnimationPhase[AnimationPhase[\"None\"] = 0] = \"None\";\n  AnimationPhase[AnimationPhase[\"Running\"] = 1] = \"Running\";\n  AnimationPhase[AnimationPhase[\"Completed\"] = 2] = \"Completed\";\n  AnimationPhase[AnimationPhase[\"Cancelled\"] = 3] = \"Cancelled\";\n})(AnimationPhase || (AnimationPhase = {}));\n\nfunction isRunningAnimation() {\n  let runningAny = false;\n  let cancelledAny = false;\n\n  for (var _len = arguments.length, phases = new Array(_len), _key = 0; _key < _len; _key++) {\n    phases[_key] = arguments[_key];\n  }\n\n  phases.forEach(phase => {\n    runningAny = runningAny || phase === AnimationPhase.Running;\n    cancelledAny = cancelledAny || phase === AnimationPhase.Cancelled;\n  });\n  return runningAny && !cancelledAny;\n}\n\nfunction didFinishAnimations() {\n  for (var _len2 = arguments.length, phases = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    phases[_key2] = arguments[_key2];\n  }\n\n  return phases.every(phase => phase === AnimationPhase.None || phase === AnimationPhase.Completed);\n}\n\nconst timeConstant = 400;\nexport function animatePointWithInertia(_ref) {\n  let {\n    from,\n    velocity,\n    onUpdate,\n    onComplete,\n    onStop\n  } = _ref;\n  const latest = from;\n  let animationPhaseX = AnimationPhase.None;\n  let animationPhaseY = AnimationPhase.None;\n  const animations = [];\n\n  const updateHandler = () => {\n    if (isRunningAnimation(animationPhaseX, animationPhaseY)) {\n      onUpdate(latest);\n    }\n  };\n\n  const completionHandler = () => {\n    if (didFinishAnimations(animationPhaseX, animationPhaseY)) {\n      onComplete();\n    }\n  };\n\n  if (velocity.x) {\n    animationPhaseX = AnimationPhase.Running;\n    animations.push(inertia({\n      from: from.x,\n      velocity: -velocity.x,\n      timeConstant,\n      onUpdate: value => {\n        latest.x = value;\n        sync.update(updateHandler, false, true);\n      },\n      onComplete: () => {\n        if (animationPhaseX !== AnimationPhase.Running) {\n          throw Error(\"animation x should be running when completing\");\n        }\n\n        animationPhaseX = AnimationPhase.Completed;\n        completionHandler();\n      }\n    }));\n  }\n\n  if (velocity.y) {\n    animationPhaseY = AnimationPhase.Running;\n    animations.push(inertia({\n      from: from.y,\n      velocity: -velocity.y,\n      timeConstant,\n      onUpdate: value => {\n        latest.y = value;\n        sync.update(updateHandler, false, true);\n      },\n      onComplete: () => {\n        if (animationPhaseY !== AnimationPhase.Running) {\n          throw Error(\"animation y should be running when completing\");\n        }\n\n        animationPhaseY = AnimationPhase.Completed;\n        completionHandler();\n      }\n    }));\n  }\n\n  if (!isRunningAnimation(animationPhaseX, animationPhaseY)) {\n    completionHandler();\n  }\n\n  return {\n    stop: () => {\n      if (!isRunningAnimation(animationPhaseX, animationPhaseY)) return;\n      animations.forEach(animation => animation.stop());\n      animationPhaseX = animationPhaseX === AnimationPhase.Running ? AnimationPhase.Cancelled : animationPhaseX;\n      animationPhaseY = animationPhaseY === AnimationPhase.Running ? AnimationPhase.Cancelled : animationPhaseY;\n      onStop();\n    }\n  };\n}","map":{"version":3,"mappings":"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","names":["sync","inertia","AnimationPhase","isRunningAnimation","runningAny","cancelledAny","phases","forEach","phase","Running","Cancelled","didFinishAnimations","every","None","Completed","timeConstant","animatePointWithInertia","from","velocity","onUpdate","onComplete","onStop","latest","animationPhaseX","animationPhaseY","animations","updateHandler","completionHandler","x","push","value","update","Error","y","stop","animation"],"sources":["../../../src/components/utils/animatePointWithInertia.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"module"}