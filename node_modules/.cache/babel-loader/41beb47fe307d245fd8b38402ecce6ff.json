{"ast":null,"code":"import { SIZE_COMPATIBILITY_WRAPPER_ATTRIBUTE } from \"../../components/hoc/withMeasuredSize.js\";\n/**\n * @internal\n *\n * Returns a plain array of references to all children, which should be\n * considered for content size calculations on this node (e.g. when running \"Fit\n * Content\" on it)\n *\n * @param element the element of the component container\n */\n\nexport function getMeasurableCodeComponentChildren(element) {\n  // Skip over withMeasuredSize compatibility wrapper\n  const childrenCollection = element.firstElementChild && element.firstElementChild.hasAttribute(SIZE_COMPATIBILITY_WRAPPER_ATTRIBUTE) ? element.firstElementChild.children : element.children;\n  return [...childrenCollection].filter(isMeasurable).map(unwrapInlinedDisplayContents);\n}\n/**\n * Rough check if an element of a HTMLCollection has measurable layout (can be\n * rendered as anything other than \"display: none\") _without_ querying its\n * computed styles, because we want to avoid a style recalculation penalty.\n *\n * @param element an HTMLCollection node\n */\n\nfunction isMeasurable(element) {\n  // Filter out certain HTMLElement subclasses that don't represent measurable elements\n  if (element instanceof HTMLBaseElement || element instanceof HTMLHeadElement || element instanceof HTMLLinkElement || element instanceof HTMLMetaElement || element instanceof HTMLScriptElement || element instanceof HTMLStyleElement || element instanceof HTMLTitleElement) {\n    return false;\n  }\n\n  return element instanceof HTMLElement || element instanceof SVGElement;\n}\n/**\n * Checks if an element has \"display: contents\" in its inline styles, and if\n * yes, returns the first measurable descendant. We intentionally _only_ check\n * the inlined display style, because reading it should not cause a style recalc\n * and it covers the use cases we have right now - wrapper divs around smart\n * components.\n *\n * @param element\n * @returns\n */\n\n\nfunction unwrapInlinedDisplayContents(element) {\n  if (!(element instanceof HTMLElement)) return element;\n  if (element.children.length === 0) return element;\n  if (element.style.display !== \"contents\") return element;\n  const firstMeasurableChild = [...element.children].find(isMeasurable);\n\n  if (firstMeasurableChild) {\n    return unwrapInlinedDisplayContents(firstMeasurableChild);\n  }\n\n  return element;\n}","map":{"version":3,"mappings":"AAAA,SAASA,oCAAT,QAAqD,0CAArD;AAEA;;;;;;;;;;AASA,OAAM,SAAUC,kCAAV,CAA6CC,OAA7C,EAA6D;AAC/D;AACA,QAAMC,kBAAkB,GACpBD,OAAO,CAACE,iBAAR,IAA6BF,OAAO,CAACE,iBAAR,CAA0BC,YAA1B,CAAuCL,oCAAvC,CAA7B,GACME,OAAO,CAACE,iBAAR,CAA0BE,QADhC,GAEMJ,OAAO,CAACI,QAHlB;AAKA,SAAO,CAAC,GAAGH,kBAAJ,EAAwBI,MAAxB,CAA+BC,YAA/B,EAA6CC,GAA7C,CAAiDC,4BAAjD,CAAP;AACH;AAED;;;;;;;;AAQA,SAASF,YAAT,CAAsBN,OAAtB,EAAmC;AAC/B;AACA,MACIA,OAAO,YAAYS,eAAnB,IACAT,OAAO,YAAYU,eADnB,IAEAV,OAAO,YAAYW,eAFnB,IAGAX,OAAO,YAAYY,eAHnB,IAIAZ,OAAO,YAAYa,iBAJnB,IAKAb,OAAO,YAAYc,gBALnB,IAMAd,OAAO,YAAYe,gBAPvB,EAQE;AACE,WAAO,KAAP;AACH;;AAED,SAAOf,OAAO,YAAYgB,WAAnB,IAAkChB,OAAO,YAAYiB,UAA5D;AACH;AAED;;;;;;;;;;;;AAWA,SAAST,4BAAT,CAAsCR,OAAtC,EAAsD;AAClD,MAAI,EAAEA,OAAO,YAAYgB,WAArB,CAAJ,EAAuC,OAAOhB,OAAP;AACvC,MAAIA,OAAO,CAACI,QAAR,CAAiBc,MAAjB,KAA4B,CAAhC,EAAmC,OAAOlB,OAAP;AACnC,MAAIA,OAAO,CAACmB,KAAR,CAAcC,OAAd,KAA0B,UAA9B,EAA0C,OAAOpB,OAAP;AAE1C,QAAMqB,oBAAoB,GAAG,CAAC,GAAGrB,OAAO,CAACI,QAAZ,EAAsBkB,IAAtB,CAA2BhB,YAA3B,CAA7B;;AACA,MAAIe,oBAAJ,EAA0B;AACtB,WAAOb,4BAA4B,CAACa,oBAAD,CAAnC;AACH;;AAED,SAAOrB,OAAP;AACH","names":["SIZE_COMPATIBILITY_WRAPPER_ATTRIBUTE","getMeasurableCodeComponentChildren","element","childrenCollection","firstElementChild","hasAttribute","children","filter","isMeasurable","map","unwrapInlinedDisplayContents","HTMLBaseElement","HTMLHeadElement","HTMLLinkElement","HTMLMetaElement","HTMLScriptElement","HTMLStyleElement","HTMLTitleElement","HTMLElement","SVGElement","length","style","display","firstMeasurableChild","find"],"sources":["../../../src/render/utils/getMeasurableCodeComponentChildren.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"module"}