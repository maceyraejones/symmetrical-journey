{"ast":null,"code":"import * as React from \"react\";\nimport { useConstant } from \"../components/utils/useConstant.js\";\nimport { useOnCurrentTargetChange } from \"../components/NavigationTargetContext.js\";\n\nfunction rejectPending(pendingTimers, pendingPromises) {\n  pendingTimers.forEach(t => clearTimeout(t));\n  pendingTimers.clear();\n  pendingPromises.forEach(reject => reject && reject(\"Callback cancelled by variant change\"));\n  pendingPromises.clear();\n}\n\nfunction createSet() {\n  return new Set();\n}\n/**\n * Create callbacks that can be cancelled if the component is unmounted, the\n * active variant changes, or the component moves out of the target screen in a\n * Framer prototype.\n *\n * @public\n */\n\n\nexport function useActiveVariantCallback(baseVariant) {\n  const pendingPromises = useConstant(createSet);\n  const pendingTimers = useConstant(createSet); // If the component moves out of the current screen in a Framer prototype,\n  // or the current screen is being unmounted via an AnimatePresence animation\n  // cancel all pending events.\n\n  useOnCurrentTargetChange(() => {\n    return () => rejectPending(pendingTimers, pendingPromises);\n  }); // If the component is unmounted, cancel all pending events.\n\n  React.useEffect(() => {\n    return () => rejectPending(pendingTimers, pendingPromises);\n  }, [pendingPromises, pendingTimers]); // If the base variant of the component changes, cancel all pending events.\n\n  React.useEffect(() => {\n    rejectPending(pendingTimers, pendingPromises);\n  }, [baseVariant, pendingPromises, pendingTimers]);\n  return React.useRef({\n    /**\n     * Create a callback that can be cancelled if the base variant changes.\n     */\n    activeVariantCallback: callback => function () {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      return new Promise((resolve, reject) => {\n        pendingPromises.add(reject);\n        return callback(...args).then(resolve);\n      }).catch(() => {// Swallow errors caused by rejecting this promise.\n      });\n    },\n\n    /**\n     * Execute a callback after a defined period of time. The callback will not\n     * be called if pending events are cancelled because the timeout will be\n     * cancelled.\n     */\n    delay: async (callback, msDelay) => {\n      await new Promise(resolve => pendingTimers.add(globalThis.setTimeout(() => resolve(true), msDelay)));\n      callback();\n    }\n  }).current;\n}\n/**\n * Create callbacks that can be cancelled if the component is unmounted, or the\n * component moves out of the target screen in a Framer prototype.\n *\n * @internal\n */\n\nexport function useActiveTargetCallback() {\n  const value = useActiveVariantCallback(undefined);\n  return React.useRef({\n    activeTargetCallback: value.activeVariantCallback,\n    delay: value.delay\n  }).current;\n}","map":{"version":3,"mappings":"AAAA,OAAO,KAAKA,KAAZ,MAAuB,OAAvB;AACA,SAASC,WAAT,QAA4B,oCAA5B;AACA,SAASC,wBAAT,QAAyC,0CAAzC;;AAMA,SAASC,aAAT,CAAuBC,aAAvB,EAAkDC,eAAlD,EAAsF;AAClFD,eAAa,CAACE,OAAd,CAAsBC,CAAC,IAAIC,YAAY,CAACD,CAAD,CAAvC;AACAH,eAAa,CAACK,KAAd;AAEAJ,iBAAe,CAACC,OAAhB,CAAwBI,MAAM,IAAIA,MAAM,IAAIA,MAAM,CAAC,sCAAD,CAAlD;AACAL,iBAAe,CAACI,KAAhB;AACH;;AAED,SAASE,SAAT,GAAkB;AACd,SAAO,IAAIC,GAAJ,EAAP;AACH;AAED;;;;;;;;;AAOA,OAAM,SAAUC,wBAAV,CAAmCC,WAAnC,EAAkE;AACpE,QAAMT,eAAe,GAAGJ,WAAW,CAAsBU,SAAtB,CAAnC;AACA,QAAMP,aAAa,GAAGH,WAAW,CAAaU,SAAb,CAAjC,CAFoE,CAIpE;AACA;AACA;;AACAT,0BAAwB,CAAC,MAAK;AAC1B,WAAO,MAAMC,aAAa,CAACC,aAAD,EAAgBC,eAAhB,CAA1B;AACH,GAFuB,CAAxB,CAPoE,CAWpE;;AACAL,OAAK,CAACe,SAAN,CAAgB,MAAK;AACjB,WAAO,MAAMZ,aAAa,CAACC,aAAD,EAAgBC,eAAhB,CAA1B;AACH,GAFD,EAEG,CAACA,eAAD,EAAkBD,aAAlB,CAFH,EAZoE,CAgBpE;;AACAJ,OAAK,CAACe,SAAN,CAAgB,MAAK;AACjBZ,iBAAa,CAACC,aAAD,EAAgBC,eAAhB,CAAb;AACH,GAFD,EAEG,CAACS,WAAD,EAAcT,eAAd,EAA+BD,aAA/B,CAFH;AAIA,SAAOJ,KAAK,CAACgB,MAAN,CAAa;AAChB;;;AAGAC,yBAAqB,EAChBC,QAAD,IACA,YAAmB;AAAA,wCAAfC,IAAe;AAAfA,YAAe;AAAA;;AACf,aAAO,IAAIC,OAAJ,CAAY,CAACC,OAAD,EAAUX,MAAV,KAAoB;AACnCL,uBAAe,CAACiB,GAAhB,CAAoBZ,MAApB;AACA,eAAOQ,QAAQ,CAAC,GAAGC,IAAJ,CAAR,CAAkBI,IAAlB,CAAuBF,OAAvB,CAAP;AACH,OAHM,EAGJG,KAHI,CAGE,MAAK,CACV;AACH,OALM,CAAP;AAMH,KAbW;;AAehB;;;;;AAKAC,SAAK,EAAE,OAAOP,QAAP,EAA6BQ,OAA7B,KAAgD;AACnD,YAAM,IAAIN,OAAJ,CAAYC,OAAO,IAAIjB,aAAa,CAACkB,GAAd,CAAkBK,UAAU,CAACC,UAAX,CAAsB,MAAMP,OAAO,CAAC,IAAD,CAAnC,EAA2CK,OAA3C,CAAlB,CAAvB,CAAN;AACAR,cAAQ;AACX;AAvBe,GAAb,EAwBJW,OAxBH;AAyBH;AAED;;;;;;;AAMA,OAAM,SAAUC,uBAAV,GAAiC;AACnC,QAAMC,KAAK,GAAGlB,wBAAwB,CAACmB,SAAD,CAAtC;AAEA,SAAOhC,KAAK,CAACgB,MAAN,CAAa;AAChBiB,wBAAoB,EAAEF,KAAK,CAACd,qBADZ;AAEhBQ,SAAK,EAAEM,KAAK,CAACN;AAFG,GAAb,EAGJI,OAHH;AAIH","names":["React","useConstant","useOnCurrentTargetChange","rejectPending","pendingTimers","pendingPromises","forEach","t","clearTimeout","clear","reject","createSet","Set","useActiveVariantCallback","baseVariant","useEffect","useRef","activeVariantCallback","callback","args","Promise","resolve","add","then","catch","delay","msDelay","globalThis","setTimeout","current","useActiveTargetCallback","value","undefined","activeTargetCallback"],"sources":["../../src/modules/useActiveVariantCallback.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"module"}