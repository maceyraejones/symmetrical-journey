{"ast":null,"code":"import { computeRelativePath, isRoute, useCurrentRouteId, getRouteElementId } from \"../router/index.js\";\nimport { isString } from \"../utils/utils.js\";\n\nfunction isTransition(value) {\n  switch (value) {\n    case \"instant\":\n    case \"push\":\n    case \"fade\":\n      return true;\n\n    default:\n      return false;\n  }\n}\n\nconst framerPageLinkAttributeVerification = {\n  transition: isTransition,\n  element: isString\n}; // This includes the comma that separates the media type from the data.\n\nconst mediaType = \"framer/page-link,\";\n/**\n * @internal\n */\n\nexport function isFramerPageLink(value) {\n  return isString(value) && value.startsWith(`data:${mediaType}`);\n}\n/**\n * @internal\n */\n\nexport function createFramerPageLink() {\n  let targetId = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const target = targetId ? targetId : \"none\";\n  const link = new URL(`data:${mediaType}${target}`);\n\n  for (const optionKey in options) link.searchParams.append(optionKey, options[optionKey]);\n\n  return link.href;\n}\n/**\n * @internal\n */\n\nexport function parseFramerPageLink(link) {\n  if (!isFramerPageLink(link)) return;\n\n  try {\n    const url = new URL(link);\n    const target = url.pathname.substring(mediaType.length);\n    const attributes = {};\n    url.searchParams.forEach((value, key) => {\n      if (key in framerPageLinkAttributeVerification) attributes[key] = value;\n    });\n    url.searchParams.delete(\"element\");\n    return {\n      target: target === \"none\" ? null : target,\n      element: attributes.element === \"none\" ? null : attributes.element,\n      attributes,\n      attributeString: url.search.substring(1)\n    };\n  } catch {\n    return;\n  }\n}\n/** A regex that searches for html tags, and href values. */\n\nconst regex = /(<([a-z]+)(?:\\s+(?!href[\\s=])[^=\\s]+=(?:'[^']*'|\"[^\"]*\"))*)(?:(\\s+href\\s*=)(?:'([^']*)'|\"([^\"]*)\"))?((?:\\s+[^=\\s]+=(?:'[^']*'|\"[^\"]*\"))*>)/gi;\n/**\n * Escape html characters that would result in invalid paths.\n * https://www.30secondsofcode.org/js/s/escape-html\n */\n\nconst escapeHTML = str => str.replace(/[&<>'\"]/g, tag => ({\n  \"&\": \"&amp;\",\n  \"<\": \"&lt;\",\n  \">\": \"&gt;\",\n  \"'\": \"&#39;\",\n  '\"': \"&quot;\"\n})[tag] || tag);\n/**\n * @internal\n */\n\n\nexport function replaceFramerPageLinks(rawHTML, getRoute, currentRouteId) {\n  return rawHTML.replace(regex, (original, pre1, tag, pre2, value1, value2, post) => {\n    if (tag.toLowerCase() !== \"a\") return original;\n    const pageLink = parseFramerPageLink(value1 || value2);\n    if (!pageLink || !pageLink.target) return original;\n    const targetRoute = getRoute(pageLink.target);\n    const currentRoute = getRoute(currentRouteId);\n    if (!isRoute(targetRoute) || !isRoute(currentRoute)) return original;\n    const targetPath = targetRoute.path;\n    const currentPath = currentRoute.path;\n    if (!targetPath || !currentPath) return original;\n    let attributes = ` ${\"data-framer-page-link-target\"\n    /* Page */\n    }=\"${pageLink.target}\" ${\"data-framer-page-link-transition\"\n    /* Transition */\n    }=\"${pageLink.attributeString}\"`;\n    const elementId = getRouteElementId(targetRoute, pageLink.element ?? undefined);\n    if (elementId) attributes += ` ${\"data-framer-page-link-element\"\n    /* Element */\n    }=\"${pageLink.element}\"`;\n    const relativePath = computeRelativePath(currentPath, targetPath);\n    return pre1 + pre2 + `\"${escapeHTML(relativePath + (elementId ? `#${elementId}` : \"\"))}\"` + attributes + post;\n  });\n}\n/**\n * @internal\n */\n\nexport function useLinkMatchesRoute(link) {\n  const currentRouteId = useCurrentRouteId();\n  if (!currentRouteId) return false;\n  const pageLink = parseFramerPageLink(link); // If we allowed page links to be active when they had an element, all page\n  // links that were to an element on the current page would always be active.\n  // We don't want that, so for now, we ignore links with elements. In future,\n  // maybe we can build a feature so that links to an element on the current\n  // page are only active when the element is in view.\n\n  return isFramerPageLink(link) && pageLink?.target === currentRouteId && !pageLink?.element;\n}","map":{"version":3,"mappings":"AAAA,SAASA,mBAAT,EAA8BC,OAA9B,EAAuDC,iBAAvD,EAA0EC,iBAA1E,QAAmG,oBAAnG;AACA,SAASC,QAAT,QAAyB,mBAAzB;;AAOA,SAASC,YAAT,CAAsBC,KAAtB,EAAoC;AAChC,UAAQA,KAAR;AACI,SAAK,SAAL;AACA,SAAK,MAAL;AACA,SAAK,MAAL;AACI,aAAO,IAAP;;AACJ;AACI,aAAO,KAAP;AANR;AAQH;;AAYD,MAAMC,mCAAmC,GAGrC;AACAC,YAAU,EAAEH,YADZ;AAEAI,SAAO,EAAEL;AAFT,CAHJ,C,CAQA;;AACA,MAAMM,SAAS,GAAG,mBAAlB;AAEA;;;;AAGA,OAAM,SAAUC,gBAAV,CAA2BL,KAA3B,EAAyC;AAC3C,SAAOF,QAAQ,CAACE,KAAD,CAAR,IAAmBA,KAAK,CAACM,UAAN,CAAiB,QAAQF,SAAS,EAAlC,CAA1B;AACH;AAED;;;;AAGA,OAAM,SAAUG,oBAAV,GAAqG;AAAA,MAAtEC,QAAsE,uEAA5C,IAA4C;AAAA,MAAtCC,OAAsC,uEAAF,EAAE;AACvG,QAAMC,MAAM,GAAGF,QAAQ,GAAGA,QAAH,GAAc,MAArC;AACA,QAAMG,IAAI,GAAG,IAAIC,GAAJ,CAAQ,QAAQR,SAAS,GAAGM,MAAM,EAAlC,CAAb;;AAEA,OAAK,MAAMG,SAAX,IAAwBJ,OAAxB,EAAiCE,IAAI,CAACG,YAAL,CAAkBC,MAAlB,CAAyBF,SAAzB,EAAoCJ,OAAO,CAACI,SAAD,CAA3C;;AAEjC,SAAOF,IAAI,CAACK,IAAZ;AACH;AAYD;;;;AAGA,OAAM,SAAUC,mBAAV,CAA8BN,IAA9B,EAA2C;AAC7C,MAAI,CAACN,gBAAgB,CAACM,IAAD,CAArB,EAA6B;;AAE7B,MAAI;AACA,UAAMO,GAAG,GAAG,IAAIN,GAAJ,CAAQD,IAAR,CAAZ;AACA,UAAMD,MAAM,GAAGQ,GAAG,CAACC,QAAJ,CAAaC,SAAb,CAAuBhB,SAAS,CAACiB,MAAjC,CAAf;AACA,UAAMC,UAAU,GAA6B,EAA7C;AACAJ,OAAG,CAACJ,YAAJ,CAAiBS,OAAjB,CAAyB,CAACvB,KAAD,EAAQwB,GAAR,KAAe;AACpC,UAAIA,GAAG,IAAIvB,mCAAX,EAAgDqB,UAAU,CAACE,GAAD,CAAV,GAAkBxB,KAAlB;AACnD,KAFD;AAGAkB,OAAG,CAACJ,YAAJ,CAAiBW,MAAjB,CAAwB,SAAxB;AACA,WAAO;AACHf,YAAM,EAAEA,MAAM,KAAK,MAAX,GAAoB,IAApB,GAA2BA,MADhC;AAEHP,aAAO,EAAEmB,UAAU,CAACnB,OAAX,KAAuB,MAAvB,GAAgC,IAAhC,GAAuCmB,UAAU,CAACnB,OAFxD;AAGHmB,gBAHG;AAIHI,qBAAe,EAAER,GAAG,CAACS,MAAJ,CAAWP,SAAX,CAAqB,CAArB;AAJd,KAAP;AAMH,GAdD,CAcE,MAAM;AACJ;AACH;AACJ;AAED;;AACA,MAAMQ,KAAK,GACP,8IADJ;AAYA;;;;;AAIA,MAAMC,UAAU,GAAIC,GAAD,IACfA,GAAG,CAACC,OAAJ,CACI,UADJ,EAEIC,GAAG,IACE;AACG,OAAK,OADR;AAEG,OAAK,MAFR;AAGG,OAAK,MAHR;AAIG,OAAK,OAJR;AAKG,OAAK;AALR,GAMCA,GAND,KAMSA,GATlB,CADJ;AAaA;;;;;AAGA,OAAM,SAAUC,sBAAV,CACFC,OADE,EAEFC,QAFE,EAGFC,cAHE,EAGqB;AAEvB,SAAOF,OAAO,CAACH,OAAR,CACHH,KADG,EAEH,CAACS,QAAD,EAAWC,IAAX,EAAyBN,GAAzB,EAAsCO,IAAtC,EAAoDC,MAApD,EAAoEC,MAApE,EAAoFC,IAApF,KAAoG;AAChG,QAAIV,GAAG,CAACW,WAAJ,OAAsB,GAA1B,EAA+B,OAAON,QAAP;AAC/B,UAAMO,QAAQ,GAAG3B,mBAAmB,CAACuB,MAAM,IAAIC,MAAX,CAApC;AACA,QAAI,CAACG,QAAD,IAAa,CAACA,QAAQ,CAAClC,MAA3B,EAAmC,OAAO2B,QAAP;AAEnC,UAAMQ,WAAW,GAAGV,QAAQ,CAACS,QAAQ,CAAClC,MAAV,CAA5B;AACA,UAAMoC,YAAY,GAAGX,QAAQ,CAACC,cAAD,CAA7B;AACA,QAAI,CAACzC,OAAO,CAACkD,WAAD,CAAR,IAAyB,CAAClD,OAAO,CAACmD,YAAD,CAArC,EAAqD,OAAOT,QAAP;AAErD,UAAMU,UAAU,GAAGF,WAAW,CAACG,IAA/B;AACA,UAAMC,WAAW,GAAGH,YAAY,CAACE,IAAjC;AACA,QAAI,CAACD,UAAD,IAAe,CAACE,WAApB,EAAiC,OAAOZ,QAAP;AAEjC,QAAIf,UAAU,GAAG,IAAI;AAAA;AAAsB,SAAKsB,QAAQ,CAAClC,MAAM,KAAK;AAAA;AAA4B,SAAKkC,QAAQ,CAAClB,eAAe,GAA7H;AAEA,UAAMwB,SAAS,GAAGrD,iBAAiB,CAACgD,WAAD,EAAcD,QAAQ,CAACzC,OAAT,IAAoBgD,SAAlC,CAAnC;AACA,QAAID,SAAJ,EAAe5B,UAAU,IAAI,IAAI;AAAA;AAAyB,SAAKsB,QAAQ,CAACzC,OAAO,GAAhE;AAEf,UAAMiD,YAAY,GAAG1D,mBAAmB,CAACuD,WAAD,EAAcF,UAAd,CAAxC;AACA,WACIT,IAAI,GAAGC,IAAP,GAAc,IAAIV,UAAU,CAACuB,YAAY,IAAIF,SAAS,GAAG,IAAIA,SAAS,EAAhB,GAAqB,EAAlC,CAAb,CAAmD,GAA/E,GAAqF5B,UAArF,GAAkGoB,IADtG;AAGH,GAxBE,CAAP;AA0BH;AAED;;;;AAGA,OAAM,SAAUW,mBAAV,CAA8B1C,IAA9B,EAA2C;AAC7C,QAAMyB,cAAc,GAAGxC,iBAAiB,EAAxC;AACA,MAAI,CAACwC,cAAL,EAAqB,OAAO,KAAP;AACrB,QAAMQ,QAAQ,GAAG3B,mBAAmB,CAACN,IAAD,CAApC,CAH6C,CAK7C;AACA;AACA;AACA;AACA;;AACA,SAAON,gBAAgB,CAACM,IAAD,CAAhB,IAA0BiC,QAAQ,EAAElC,MAAV,KAAqB0B,cAA/C,IAAiE,CAACQ,QAAQ,EAAEzC,OAAnF;AACH","names":["computeRelativePath","isRoute","useCurrentRouteId","getRouteElementId","isString","isTransition","value","framerPageLinkAttributeVerification","transition","element","mediaType","isFramerPageLink","startsWith","createFramerPageLink","targetId","options","target","link","URL","optionKey","searchParams","append","href","parseFramerPageLink","url","pathname","substring","length","attributes","forEach","key","delete","attributeString","search","regex","escapeHTML","str","replace","tag","replaceFramerPageLinks","rawHTML","getRoute","currentRouteId","original","pre1","pre2","value1","value2","post","toLowerCase","pageLink","targetRoute","currentRoute","targetPath","path","currentPath","elementId","undefined","relativePath","useLinkMatchesRoute"],"sources":["../../src/modules/framerPageLink.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"module"}