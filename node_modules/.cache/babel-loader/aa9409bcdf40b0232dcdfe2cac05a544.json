{"ast":null,"code":"import * as React from \"react\";\nimport { ResizeObserver as ResizeObserverPolyfill } from \"@juggle/resize-observer\";\nimport { isBrowser } from \"../../utils/environment.js\";\nimport { useForceUpdate } from \"../../modules/useForceUpdate.js\";\nimport { safeWindow } from \"../../utils/safeWindow.js\";\nimport { useIsomorphicLayoutEffect } from \"../../useIsomorphicLayoutEffect.js\";\nconst DEFAULT_SIZE = 200;\n\nclass SharedObserver {\n  #sharedResizeObserver;\n  #callbacks = new WeakMap();\n\n  constructor() {\n    const ResizeObserver = safeWindow.ResizeObserver ?? ResizeObserverPolyfill;\n    this.#sharedResizeObserver = new ResizeObserver(this.updateResizedElements.bind(this));\n  }\n\n  updateResizedElements(entries) {\n    for (const entry of entries) {\n      const callbackForElement = this.#callbacks.get(entry.target);\n      if (callbackForElement) callbackForElement(entry.contentRect);\n    }\n  }\n\n  observeElementWithCallback(element, callback) {\n    this.#sharedResizeObserver.observe(element);\n    this.#callbacks.set(element, callback);\n  }\n\n  unobserve(element) {\n    this.#sharedResizeObserver.unobserve(element);\n    this.#callbacks.delete(element);\n  }\n\n}\n\nconst sharedResizeObserver = isBrowser() ? new SharedObserver() : undefined;\n/**\n * Uses a globally shared resize observer, and returns an updated\n * size object when the element's size changes. This is the recommended way to\n * use a Resize Observer: https://github.com/WICG/resize-observer/issues/59.\n */\n\nfunction useMeasuredSize(ref) {\n  const forceUpdate = useForceUpdate();\n  const size = React.useRef(null);\n\n  function updateSize(newSize) {\n    // Ignore 0 entries, usually indicative of an element that is hidden, or\n    // nested inside a hidden element. This is common on the canvas where\n    // elements out of the viewport will be contained in an element with\n    // `display: none`. We could technically check the bounding client rect\n    // to make sure the element isn't visible, but that would force a style\n    // recalc and negate any performance benefits of skipping the update\n    if (newSize.width === 0 && newSize.height === 0) return;\n\n    if (!size.current || newSize.height !== size.current.height || newSize.width !== size.current.width) {\n      size.current = {\n        width: newSize.width,\n        height: newSize.height\n      };\n      forceUpdate();\n    }\n  } // On mount, immediately measure and set a size. This will defer paint until\n  // no more updates are scheduled. Additionally add our element to the shared\n  // ResizeObserver with a callback to perform when the element resizes.\n  // Finally, remove the element from the observer when the component is unmounted.\n\n\n  useIsomorphicLayoutEffect(() => {\n    if (!ref.current) return;\n    const {\n      offsetWidth,\n      offsetHeight\n    } = ref.current; // Defer paint until initial size is added.\n\n    updateSize({\n      width: offsetWidth,\n      height: offsetHeight\n    }); // Resize observer will race to add the initial size, but since the size\n    // is set above, it won't trigger a render on mount since it should\n    // match the measured size. Future executions of the callback will\n    // trigger renders if the size changes.\n\n    sharedResizeObserver.observeElementWithCallback(ref.current, updateSize);\n    return () => {\n      if (!ref.current) return;\n      sharedResizeObserver.unobserve(ref.current);\n    };\n  }, []);\n  return size.current;\n}\n/**\n * @internal\n */\n\n\nexport const SIZE_COMPATIBILITY_WRAPPER_ATTRIBUTE = \"data-framer-size-compatibility-wrapper\";\n/**\n * A HoC to enhance code components that depend on being rendered with exact\n * width and height props with width and height props determined via a shared\n * ResizeObserver.\n *\n * @FIXME Do not depend on this HoC. The current plan is to turn it into a no-op\n * after a deprecation period. If we need to provide this functionality to\n * customers after we migrate to a modules-first ecosystem, then we can provide\n * a new copy of this HoC or the `useMeasuredSize` hook, and recommend use\n * without a module version, allowing everyone to share the same ResizeObserver\n * on a single canvas.\n *\n * @internal\n */\n\nexport const withMeasuredSize = Component => props => {\n  const ref = React.useRef(null);\n  const size = useMeasuredSize(ref);\n  const dataProps = {\n    [SIZE_COMPATIBILITY_WRAPPER_ATTRIBUTE]: true\n  }; // The initial render will be delayed until the measured size is available.\n\n  const shouldRender = Boolean(size); // In the export case, we'll sometimes be provided with explicit width and\n  // height to use as fallback. This is a temporary measure and will only\n  // happen when the used width / height is a fixed number. This code should\n  // be removed once we're no longer using `renderToStaticMarkup` for export.\n\n  const fallbackWidth = props.width ?? DEFAULT_SIZE;\n  const fallbackHeight = props.height ?? DEFAULT_SIZE;\n  return React.createElement(\"div\", {\n    style: {\n      width: \"100%\",\n      height: \"100%\",\n      pointerEvents: \"none\"\n    },\n    ref: ref,\n    ...dataProps\n  }, shouldRender && React.createElement(Component, { ...props,\n    width: size?.width ?? fallbackWidth,\n    height: size?.height ?? fallbackHeight\n  }));\n};","map":{"version":3,"mappings":"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","names":["React","ResizeObserver","ResizeObserverPolyfill","isBrowser","useForceUpdate","safeWindow","useIsomorphicLayoutEffect","DEFAULT_SIZE","SharedObserver","WeakMap","constructor","updateResizedElements","bind","entries","entry","callbackForElement","get","target","contentRect","observeElementWithCallback","element","callback","observe","set","unobserve","delete","sharedResizeObserver","undefined","useMeasuredSize","ref","forceUpdate","size","useRef","updateSize","newSize","width","height","current","offsetWidth","offsetHeight","SIZE_COMPATIBILITY_WRAPPER_ATTRIBUTE","withMeasuredSize","Component","props","dataProps","shouldRender","Boolean","fallbackWidth","fallbackHeight","style","pointerEvents"],"sources":["../../../src/components/hoc/withMeasuredSize.tsx"],"sourcesContent":[null]},"metadata":{},"sourceType":"module"}