{"ast":null,"code":"import * as React from \"react\";\nimport { useRef, useCallback, useContext, useMemo } from \"react\";\n/**\n * @internal\n */\n\nexport const LayoutIdContext = React.createContext({\n  getLayoutId: args => null,\n  persistLayoutIdCache: () => {},\n  top: false,\n  enabled: true\n}); // FIXME: This pattern currently not supported by rules-of-hooks, see\n// https://github.com/facebook/react/pull/18341#issuecomment-749659456\n\n/* eslint-disable react-hooks/rules-of-hooks */\n\n/**\n * @internal\n */\n\nexport function LayoutIdProvider(_ref) {\n  let {\n    children\n  } = _ref;\n  const context = useContext(LayoutIdContext); // Since Code Components on the canvas can use Navigation, we need to ensure\n  // that only the root LayoutIdContext is generating layoutIds so that the\n  // cache is shared across all screens.\n\n  if (context.top) return React.createElement(React.Fragment, null, children);\n  const cache = useRef({\n    // When we provide a layoutId for a node based on it's first\n    // duplicatedFrom id, we save it's layoutId mapped to it's actual id.\n    // Future screen's nodes will check this cache first, to see if they've\n    // previously been assigned a layoutId, or if any of there other\n    // duplicatedFrom ids matched a node that was previously assigned a\n    // layoutId.\n    byId: {},\n    byName: {},\n    // When we navigate from screens that were duplicated from a future\n    // screen, to that future screen, we want to do a reverse lookup on the\n    // last duplicatedFrom id, rather than the id. We need to keep them\n    // separate so they don't overlap.\n    byLastId: {},\n    byPossibleId: {},\n    byLastName: {},\n    byLayoutId: {},\n    // When we don't have a cached layoutId for all duplicatedFrom ids, we\n    // need to increment and save it so that we don't create clashing\n    // layoutIds. We also need to reset name counts between screens, so we\n    // record those separately.\n    count: {\n      byId: {},\n      byName: {}\n    }\n  });\n  const screen = useRef({\n    byId: {},\n    byName: {},\n    byLastId: {},\n    byPossibleId: {},\n    byLastName: {},\n    byLayoutId: {}\n  }); // Keep track of which layoutIds have been used on the current screen so\n  // that we avoid reassigning them, and instead, use other methods to\n  // generate a unique id.\n\n  const usedIds = useRef(new Set()).current; // This function is quite abstract so I've done my best to annotate why\n  // checks are happening. A lot of the complexity comes from handling named\n  // and unnamed layers differently.\n\n  const getLayoutId = useCallback(_ref2 => {\n    let {\n      id,\n      name,\n      duplicatedFrom\n    } = _ref2;\n    // Code components that use Frame's should not receive a layout id\n    // from our context. However this will be bypassed if end-users add an\n    // id to their Frame in code.\n    if (!id) return null;\n    const cacheKey = name ? \"byName\" : \"byId\"; // If we've previously recorded an layout id for this node, reuse it\n    // and return early.\n\n    const previousId = cache.current[cacheKey][id];\n    if (previousId) return previousId; // If the node is an original node (hasn't been duplicated from another\n    // node), we use it's name or id, unless it's name or id was already\n    // used on this screen, or used by a node that wasn't last duplicated\n    // from this node on the previous screen (suggesting another node on\n    // this screen will need to use this id in a future call).\n\n    const nodeIdentifier = name || id;\n\n    if (!duplicatedFrom && !usedIds.has(nodeIdentifier) && (!cache.current.byLayoutId[nodeIdentifier] || cache.current.byLayoutId[nodeIdentifier] === nodeIdentifier)) {\n      if (cache.current.count[cacheKey][nodeIdentifier] === undefined) {\n        cache.current.count[cacheKey][nodeIdentifier] = 0;\n        cache.current.byLayoutId[nodeIdentifier] = nodeIdentifier;\n        screen.current[cacheKey][id] = nodeIdentifier;\n      }\n\n      usedIds.add(nodeIdentifier);\n      return nodeIdentifier;\n    } // If a node is duplicated, check if an layout id was assigned to it\n    // on the last screen. Use that layout id if it's not already been\n    // used on this screen. This ensures that nodes duplicated from a\n    // specific layer on one screen, preserve their connection even if they\n    // are in a different hierarchical order on the current screen. This is\n    // not relevant for design components since their layers are always in\n    // the same order. We also check for matches against `byLastId`, but\n    // only use them after we explicitly check `id`.\n\n\n    let possibleMatch = undefined;\n\n    if (duplicatedFrom?.length) {\n      for (let index = duplicatedFrom.length - 1; index >= 0; index--) {\n        const duplicatedId = duplicatedFrom[index];\n        const match = cache.current[cacheKey][duplicatedId];\n        const byLastIdMatch = cache.current.byLastId[duplicatedId]; // In the event that no match is found for the duplicatedFrom id\n        // in the `byId` or `byName` cache, it's possible we will need\n        // to loop through the duplicatedFrom ids again, to check if\n        // there is a match against the `byLastId` cache. Rather than\n        // performing that loop again, we can save the first successful\n        // match here, and use it when it's the correct option later.\n        // This is safe because we will only use this match if there is\n        // no match against `byId` or `byName`, meaning we will always\n        // have looped through all of the duplicatedFrom ids.\n\n        if (byLastIdMatch && !possibleMatch) {\n          const matchedLayoutId = cache.current.byLayoutId[byLastIdMatch];\n          const shouldUseNamedLastIdMatch = !matchedLayoutId || matchedLayoutId === name;\n\n          if (byLastIdMatch && !usedIds.has(byLastIdMatch) && (name ? shouldUseNamedLastIdMatch : true)) {\n            possibleMatch = [byLastIdMatch, duplicatedId];\n          }\n        } // If the match from the previous screen is a name match, ensure it is was assigned to the exact same name.\n\n\n        const previousLayoutId = cache.current.byLayoutId[match];\n        const shouldUseNamedMatch = !previousLayoutId || previousLayoutId === name;\n\n        if (match && !usedIds.has(match) && (name ? shouldUseNamedMatch : true)) {\n          screen.current[cacheKey][id] = match;\n          screen.current.byLastId[duplicatedId] = match;\n          usedIds.add(match);\n          return match;\n        }\n      }\n    } // In cases where we're starting on a screen that uses frames duplicated\n    // from a future screen, when we arrive on the future screen, we need to\n    // make sure we preserve that connection. This handles direct\n    // relationships. For example starting on a frame that was duplicated\n    // directly from the previous frame, and transitioning to that previous\n    // frame.\n\n\n    const last = cache.current.byLastId[id];\n\n    if (last && !usedIds.has(last)) {\n      usedIds.add(last);\n      screen.current.byId[id] = last;\n      return last;\n    } // If we set a possible match by checking duplicatedFrom ids against\n    // `byLastId`, and we weren't able to find a match against the `byId` or\n    // `byName`, or by directly looking up the node's id against `byLastId`,\n    // use a possible match if it was set.\n\n\n    if (possibleMatch) {\n      const [match, duplicatedId] = possibleMatch;\n      screen.current[cacheKey][id] = match;\n      screen.current.byLastId[duplicatedId] = match;\n      usedIds.add(match);\n      return match;\n    } // In cases where we're starting on a screen that uses frames duplicated\n    // from a future screen, when we arrive on the future screen, we need to\n    // make sure we preserve that connection. This handles indirect\n    // relationships. For example starting on the last frame duplicated many\n    // times from an initial frame, and transitioning directly to that\n    // initial frame.\n\n\n    const possible = cache.current.byPossibleId[id];\n\n    if (possible && !usedIds.has(possible)) {\n      usedIds.add(possible);\n      screen.current.byId[id] = possible;\n      return possible;\n    }\n\n    const rootDuplicatedId = duplicatedFrom?.[0]; // If a node hasn't been assigned a layout id on a previous screen,\n    // or if that layout id has already been used, or if this is the\n    // first screen, generate a unique layout id by incrementing a\n    // counter for that name or duplicatedId.\n\n    const identifier = name || rootDuplicatedId || id;\n    const value = cache.current.count[cacheKey][identifier] + 1 || 0;\n    const {\n      layoutId,\n      value: nextValue\n    } = nextLayoutId(identifier, value, usedIds);\n    cache.current.count[cacheKey][identifier] = nextValue;\n    screen.current[cacheKey][id] = layoutId;\n\n    if (duplicatedFrom?.length) {\n      // TODO: Should name use it's own map?\n      if (!name) {\n        screen.current.byLastId[duplicatedFrom[duplicatedFrom.length - 1]] = layoutId;\n\n        if (duplicatedFrom.length > 1) {\n          // Skipping the most recent duplicatedFrom, and only setting\n          // it if there isn't already one set. This isn't a perfect\n          // heuristic since it allows layout hierarchy to influence\n          // matches, since we have to assign on a\n          // first-come-first-serve basis.\n          for (let index = 0; index < duplicatedFrom.length - 1; index++) {\n            const possibleId = duplicatedFrom[index];\n\n            if (!screen.current.byPossibleId[possibleId]) {\n              screen.current.byPossibleId[possibleId] = layoutId;\n            }\n          }\n        }\n      }\n    }\n\n    screen.current.byLayoutId[layoutId] = nodeIdentifier;\n    usedIds.add(layoutId);\n    return layoutId;\n  }, []);\n  const persistLayoutIdCache = useCallback(() => {\n    cache.current = {\n      byId: { ...cache.current.byId,\n        ...screen.current.byId\n      },\n      byLastId: { ...cache.current.byLastId,\n        ...screen.current.byLastId\n      },\n      byPossibleId: { ...cache.current.byPossibleId,\n        ...screen.current.byPossibleId\n      },\n      byName: { ...cache.current.byName,\n        ...screen.current.byName\n      },\n      byLastName: { ...cache.current.byLastName,\n        ...screen.current.byLastName\n      },\n      byLayoutId: { ...cache.current.byLayoutId,\n        ...screen.current.byLayoutId\n      },\n      // Unlike the count.byId, we need to reset the count.byName because\n      // named layers might not have duplicatedFrom ids (e.g. imported\n      // from Figma). When we can use duplicatedFrom ids to check if an id\n      // was assigned on a previous screen, we don't increment the count,\n      // which means that the count only increments for new items, and\n      // only increments on a new screen if the node is new. Since named\n      // layers need to always match in some way between screens, we reset\n      // the count so that the second named layer on a second screen is\n      // always name-1 if it doesn't have any duplicatedFrom ids.\n      count: { ...cache.current.count,\n        byName: {}\n      }\n    };\n    screen.current = {\n      byId: {},\n      byName: {},\n      byLastId: {},\n      byPossibleId: {},\n      byLastName: {},\n      byLayoutId: {}\n    };\n    usedIds.clear();\n  }, []); // Bind the context value to a ref so that it doesn't change between\n  // renders, which cases all subscribed descendants to update.\n  // eslint-disable-next-line react-hooks/rules-of-hooks\n\n  const contextValue = useRef({\n    getLayoutId,\n    persistLayoutIdCache,\n    top: true,\n    enabled: true\n  }).current;\n  return React.createElement(LayoutIdContext.Provider, {\n    value: contextValue\n  }, children);\n} // FIXME (See top of function)\n\n/* eslint-enable react-hooks/rules-of-hooks */\n\nfunction nextLayoutId(identifier, initialValue, usedIds) {\n  let value = initialValue; // We expect 0 to be falsy here so that generated ids match with\n  // original ids.\n\n  let layoutId = value ? `${identifier}-${value}` : identifier;\n\n  while (usedIds.has(layoutId)) {\n    value++;\n    layoutId = `${identifier}-${value}`;\n  }\n\n  return {\n    layoutId,\n    value\n  };\n}\n/**\n * Enable or disable the automatic generation of layout ids for canvas layers.\n * By default layout ids are generated for all layers created on the Framer\n * canvas. However, layout ids are not generated for any layer that is a\n * descendant of a code component. Sometimes you will want to enable layout id\n * generation for descendants of your code components when they use children,\n * slots, or import design components, and you want those layers to animate with\n * magic motion transitions.\n *\n * You can enable that behavior by wrapping your code component like this\n * ```typescript\n * <AutomaticLayoutIds enabled>\n *  <YourComponent/>\n * </AutomaticLayoutIds>\n * ```\n * @public\n */\n\n\nexport function AutomaticLayoutIds(_ref3) {\n  let {\n    enabled = true,\n    ...props\n  } = _ref3;\n  const context = useContext(LayoutIdContext);\n  const contextValue = useMemo(() => {\n    return { ...context,\n      enabled\n    };\n  }, [enabled]);\n  return React.createElement(LayoutIdContext.Provider, { ...props,\n    value: contextValue\n  });\n}","map":{"version":3,"mappings":"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","names":["React","useRef","useCallback","useContext","useMemo","LayoutIdContext","createContext","getLayoutId","args","persistLayoutIdCache","top","enabled","LayoutIdProvider","children","context","cache","byId","byName","byLastId","byPossibleId","byLastName","byLayoutId","count","screen","usedIds","Set","current","id","name","duplicatedFrom","cacheKey","previousId","nodeIdentifier","has","undefined","add","possibleMatch","length","index","duplicatedId","match","byLastIdMatch","matchedLayoutId","shouldUseNamedLastIdMatch","previousLayoutId","shouldUseNamedMatch","last","possible","rootDuplicatedId","identifier","value","layoutId","nextValue","nextLayoutId","possibleId","clear","contextValue","Provider","initialValue","AutomaticLayoutIds","props"],"sources":["../../../src/components/AnimateLayout/LayoutIdContext.tsx"],"sourcesContent":[null]},"metadata":{},"sourceType":"module"}