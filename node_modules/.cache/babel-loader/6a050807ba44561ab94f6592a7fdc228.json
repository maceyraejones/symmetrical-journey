{"ast":null,"code":"import * as React from \"react\";\nimport { isObject } from \"../utils/utils.js\";\nimport { useOnCurrentTargetChange } from \"../components/NavigationTargetContext.js\";\nimport { useConstant } from \"../components/utils/useConstant.js\";\n/** @internal */\n\nexport function isFramerGamepadKeydownData(value) {\n  return isObject(value) && value.mapping !== undefined;\n}\n\nfunction gamepadInputsHaveChanged(previous, current) {\n  if (previous.length !== current.length) return true;\n  if (!previous.every((item, i) => current[i] === item)) return true;\n  return false;\n}\n/**\n * Exported for testing.\n * @internal\n */\n\n\nexport function createGamepadPoller() {\n  const handlers = new Set();\n  let isConnected = false;\n  let isPolling = null;\n  let lastKeys = [];\n\n  const startPolling = () => {\n    const input = getGamepadInputs(); // Don't do anything if no gamepad is connected\n\n    if (!input) return;\n    const {\n      gamepad,\n      inputs\n    } = input;\n    const {\n      mapping,\n      id\n    } = gamepad; // Each frame only knows its own last pressed key. If two continuous\n    // frames both have gamepad events binding on the same key, we don't\n    // want to fire two events in a row.\n\n    if (gamepadInputsHaveChanged(lastKeys, inputs)) handlers.forEach(handler => handler({\n      inputs,\n      mapping,\n      id\n    }));\n    lastKeys = inputs;\n    isPolling = window.requestAnimationFrame(startPolling);\n  };\n\n  const handleConnection = () => {\n    if (isConnected || isPolling) return;\n    startPolling();\n    isConnected = true;\n  };\n\n  const stopPolling = () => {\n    if (!isPolling) return;\n    window.cancelAnimationFrame(isPolling);\n    isPolling = null;\n  };\n\n  const handleDisconnection = () => {\n    if (!isConnected) return;\n    stopPolling();\n    isConnected = false;\n  };\n\n  const setupAndStartPolling = () => {\n    if (isPolling) return;\n    const gamepad = getGamepadInputs();\n\n    if (!gamepad) {\n      // @NOTE: gamepadconnected only exists on window\n      // https://developer.mozilla.org/en-US/docs/Web/API/Window/gamepadconnected_event\n      window.addEventListener(\"gamepadconnected\", handleConnection);\n      return;\n    } // Even if we haven't connected yet, we need to make sure we disconnect\n    // in the future.\n\n\n    window.addEventListener(\"gamepaddisconnected\", handleDisconnection);\n    isConnected = true;\n    startPolling();\n  };\n\n  const cleanupAndStopPolling = () => {\n    if (!isPolling) return; // If the gamepad is already connected, then this event has no use\n    // anymore; if the gamepad is not connected yet, we will only listen to\n    // it when start polling. So we should remove the event listener anyway.\n\n    window.removeEventListener(\"gamepadconnected\", handleConnection);\n    window.removeEventListener(\"gamepaddisconnected\", handleDisconnection);\n    stopPolling();\n  };\n\n  return {\n    register(callback) {\n      if (handlers.size === 0) setupAndStartPolling();\n      handlers.add(callback);\n    },\n\n    unregister(callback) {\n      handlers.delete(callback);\n      if (handlers.size === 0) cleanupAndStopPolling();\n    }\n\n  };\n}\n/** @internal */\n\nexport const GamepadContext = React.createContext(createGamepadPoller());\n/**\n * Return the first gamepad that has input together with the input keys. If\n * there's no input, return the first available gamepad. If there's no gamepad\n * connected, return null.\n */\n\nfunction getGamepadInputs() {\n  let firstConnectedGamepad = null;\n  const gamepads = navigator.getGamepads();\n\n  for (const gamepad of gamepads) {\n    if (!gamepad) continue;\n    if (!firstConnectedGamepad) firstConnectedGamepad = gamepad;\n    const inputs = [...scanPressedAxis(gamepad), ...scanPressedButtons(gamepad)];\n    if (inputs.length > 0) return {\n      gamepad,\n      inputs\n    };\n  }\n\n  if (firstConnectedGamepad) return {\n    gamepad: firstConnectedGamepad,\n    inputs: []\n  };\n  return null;\n}\n\nfunction scanPressedAxis(gamepad) {\n  const axes = [];\n\n  for (const [idx, axis] of gamepad.axes.entries()) {\n    // Normally axis 0&1 are allocated for the left stick, and 3&4 for the\n    // right stick. Depending on the browser, some controllers can have more\n    // than 4 axes. For example, in safari, a PS5 Dualsense controller has\n    // its axis 4&5 for the left/right triggers, that are set to -1 when\n    // idling. We don't want these axes to be taken as pressed.\n    if (idx > 3) continue;\n    if (axis <= -0.5) axes.push(`Axis ${idx}-`);\n    if (axis > 0.5) axes.push(`Axis ${idx}+`);\n  }\n\n  return axes;\n}\n\nfunction scanPressedButtons(gamepad) {\n  const buttons = [];\n\n  for (const [idx, button] of gamepad.buttons.entries()) {\n    if (isButtonPressed(button)) buttons.push(`Button ${idx}`);\n  }\n\n  return buttons;\n}\n\nfunction isButtonPressed(button) {\n  // button.value represents the current state of analog buttons\n  return button.pressed === true || button.value > 0;\n}\n/**\n * Register a callback to be executed when a gamepad button is pressed and the\n * registering component is in the current Framer navigation target. Optionally\n * provide a specific gamepad mapping, or flag the hook to operate on keyup.\n *\n *  @public\n */\n\n\nexport function useGamepad(input, callback) {\n  let {\n    mapping,\n    on\n  } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const context = React.useContext(GamepadContext);\n  const settings = useConstant(() => ({\n    mapping: mapping ?? \"standard\",\n    on: on ?? \"keydown\"\n  }));\n  const stateRef = React.useRef({\n    pressed: false,\n    handler: callback\n  });\n  const cb = React.useCallback(gamepad => {\n    const {\n      pressed,\n      handler\n    } = stateRef.current;\n\n    if (gamepad.inputs.includes(input) && settings.mapping === gamepad.mapping) {\n      settings.on === \"keydown\" && handler();\n      stateRef.current.pressed = true;\n    } else if (pressed) {\n      settings.on === \"keyup\" && handler();\n      stateRef.current.pressed = false;\n    }\n  }, [input, settings]);\n  useOnCurrentTargetChange((isInTarget, isOverlayed) => {\n    const isActive = isInTarget && !isOverlayed;\n\n    if (isActive) {\n      context.register(cb);\n    } else {\n      context.unregister(cb);\n    } // Unregister the callback when the screen unmounts. This is probably\n    // unnecessary since we unregister the callback when the component\n    // unmounts, but may catch instances where the screen is being unmounted\n    // with AnimatePresence and hasn't yet been removed from the react tree.\n\n\n    return () => context.unregister(cb);\n  }, []); // Unregister the callback when unmounted.\n\n  React.useEffect(() => {\n    return () => context.unregister(cb);\n  }, [cb, context]); // Maintain an up to date reference to the provided callback. This prevents\n  // users from being forced to create a memoized callback with useCallback\n  // and React refs.\n\n  React.useEffect(() => {\n    stateRef.current.handler = callback;\n  }, [callback]);\n}","map":{"version":3,"mappings":"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","names":["React","isObject","useOnCurrentTargetChange","useConstant","isFramerGamepadKeydownData","value","mapping","undefined","gamepadInputsHaveChanged","previous","current","length","every","item","i","createGamepadPoller","handlers","Set","isConnected","isPolling","lastKeys","startPolling","input","getGamepadInputs","gamepad","inputs","id","forEach","handler","window","requestAnimationFrame","handleConnection","stopPolling","cancelAnimationFrame","handleDisconnection","setupAndStartPolling","addEventListener","cleanupAndStopPolling","removeEventListener","register","callback","size","add","unregister","delete","GamepadContext","createContext","firstConnectedGamepad","gamepads","navigator","getGamepads","scanPressedAxis","scanPressedButtons","axes","idx","axis","entries","push","buttons","button","isButtonPressed","pressed","useGamepad","on","context","useContext","settings","stateRef","useRef","cb","useCallback","includes","isInTarget","isOverlayed","isActive","useEffect"],"sources":["../../src/modules/useGamepad.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"module"}