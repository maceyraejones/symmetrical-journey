{"ast":null,"code":"import * as React from \"react\";\nimport { createContext, useContext, useRef, useCallback, useEffect } from \"react\";\nimport { isFunction } from \"../utils/utils.js\";\nimport { useMap } from \"./utils/useMap.js\";\nconst NavigationTargetContext = createContext({\n  register: () => {},\n  deregister: () => {}\n});\n/**\n * @internal\n *\n * Run the registered callback when the current navigation target changes\n * @param isCurrent If the ground node is present as the current target in the preview\n */\n\nexport const NavigationTargetWrapper = _ref => {\n  let {\n    isCurrent,\n    isOverlayed,\n    children\n  } = _ref;\n  const callbacks = useMap();\n  const register = useCallback(fn => {\n    if (callbacks.has(fn)) {\n      // Should never happen\n      // eslint-disable-next-line no-console\n      console.warn(\"NavigationTargetWrapper: already registered\");\n      return;\n    }\n\n    callbacks.set(fn, undefined);\n  }, [callbacks\n  /* constant, so should never change */\n  ]);\n  const deregister = useCallback(fn => {\n    // Cleanup before removing the callback\n    const cleanup = callbacks.get(fn);\n    cleanup?.();\n    callbacks.delete(fn);\n  }, [callbacks\n  /* constant, so should never change */\n  ]);\n  const value = useRef({\n    register,\n    deregister\n  }).current;\n  useEffect(() => {\n    callbacks.forEach((_, cb) => {\n      const newCleanup = cb(isCurrent, isOverlayed);\n      callbacks.set(cb, isFunction(newCleanup) ? newCleanup : undefined);\n    });\n    return () => {\n      callbacks.forEach((cleanup, cb) => {\n        if (!cleanup) return; // Cleanup and remove cleanup callback so we never call it more than once\n\n        cleanup();\n        callbacks.set(cb, undefined);\n      });\n    };\n  }, [isCurrent, isOverlayed, callbacks\n  /* constant, so should never change */\n  ]);\n  return React.createElement(NavigationTargetContext.Provider, {\n    value: value\n  }, children);\n};\n/**\n * @internal\n *\n * Register the callback on mount to the NavigationTargetWrapper, deregister it on unmount.\n * The callback will be fired when the current target changes. The callback allows a cleanup callback to be returned.\n * The cleanup will fire before the next update and on unmount.\n * @param callback A callback that receives the `isCurrent` state of the NavigateTargetWrapper\n * @param deps If present, callback will be renewed when the dependencies change.\n */\n\nexport function useOnCurrentTargetChange(callback) {\n  let deps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  const {\n    register,\n    deregister\n  } = useContext(NavigationTargetContext);\n  useEffect(() => {\n    if (!callback) return;\n    register(callback);\n    return () => deregister(callback); // callback should not change while previewing\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [register, deregister, ...deps]);\n}","map":{"version":3,"mappings":"AAAA,OAAO,KAAKA,KAAZ,MAAuB,OAAvB;AACA,SAASC,aAAT,EAAwBC,UAAxB,EAAoCC,MAApC,EAA4CC,WAA5C,EAAyDC,SAAzD,QAA0E,OAA1E;AACA,SAASC,UAAT,QAA2B,mBAA3B;AACA,SAASC,MAAT,QAAuB,mBAAvB;AAKA,MAAMC,uBAAuB,GAAGP,aAAa,CAG1C;AAAEQ,UAAQ,EAAE,MAAK,CAAG,CAApB;AAAsBC,YAAU,EAAE,MAAK,CAAG;AAA1C,CAH0C,CAA7C;AAOA;;;;;;;AAMA,OAAO,MAAMC,uBAAuB,GAAG,QAAgD;AAAA,MAA/C;AAAEC,aAAF;AAAaC,eAAb;AAA0BC;AAA1B,GAA+C;AACnF,QAAMC,SAAS,GAAGR,MAAM,EAAxB;AAEA,QAAME,QAAQ,GAAGL,WAAW,CACvBY,EAAD,IAA0B;AACtB,QAAID,SAAS,CAACE,GAAV,CAAcD,EAAd,CAAJ,EAAuB;AACnB;AACA;AACAE,aAAO,CAACC,IAAR,CAAa,6CAAb;AACA;AACH;;AACDJ,aAAS,CAACK,GAAV,CAAcJ,EAAd,EAAkBK,SAAlB;AACH,GATuB,EAUxB,CAACN;AAAU;AAAX,GAVwB,CAA5B;AAaA,QAAML,UAAU,GAAGN,WAAW,CACzBY,EAAD,IAA0B;AACtB;AACA,UAAMM,OAAO,GAAGP,SAAS,CAACQ,GAAV,CAAcP,EAAd,CAAhB;AACAM,WAAO;AACPP,aAAS,CAACS,MAAV,CAAiBR,EAAjB;AACH,GANyB,EAO1B,CAACD;AAAU;AAAX,GAP0B,CAA9B;AAUA,QAAMU,KAAK,GAAGtB,MAAM,CAAC;AAAEM,YAAF;AAAYC;AAAZ,GAAD,CAAN,CAAiCgB,OAA/C;AAEArB,WAAS,CAAC,MAAK;AACXU,aAAS,CAACY,OAAV,CAAkB,CAACC,CAAD,EAAIC,EAAJ,KAAU;AACxB,YAAMC,UAAU,GAAGD,EAAE,CAACjB,SAAD,EAAYC,WAAZ,CAArB;AACAE,eAAS,CAACK,GAAV,CAAcS,EAAd,EAAkBvB,UAAU,CAACwB,UAAD,CAAV,GAAyBA,UAAzB,GAAsCT,SAAxD;AACH,KAHD;AAIA,WAAO,MAAK;AACRN,eAAS,CAACY,OAAV,CAAkB,CAACL,OAAD,EAAUO,EAAV,KAAgB;AAC9B,YAAI,CAACP,OAAL,EAAc,OADgB,CAE9B;;AACAA,eAAO;AACPP,iBAAS,CAACK,GAAV,CAAcS,EAAd,EAAkBR,SAAlB;AACH,OALD;AAMH,KAPD;AAQH,GAbQ,EAaN,CAACT,SAAD,EAAYC,WAAZ,EAAyBE;AAAU;AAAnC,GAbM,CAAT;AAeA,SAAOf,oBAACQ,uBAAuB,CAACuB,QAAzB,EAAiC;AAACN,SAAK,EAAEA;AAAR,GAAjC,EAAiDX,QAAjD,CAAP;AACH,CA5CM;AA8CP;;;;;;;;;;AASA,OAAM,SAAUkB,wBAAV,CAAmCC,QAAnC,EAA+F;AAAA,MAA/BC,IAA+B,uEAAF,EAAE;AACjG,QAAM;AAAEzB,YAAF;AAAYC;AAAZ,MAA2BR,UAAU,CAACM,uBAAD,CAA3C;AACAH,WAAS,CAAC,MAAK;AACX,QAAI,CAAC4B,QAAL,EAAe;AACfxB,YAAQ,CAACwB,QAAD,CAAR;AACA,WAAO,MAAMvB,UAAU,CAACuB,QAAD,CAAvB,CAHW,CAIX;AACA;AACH,GANQ,EAMN,CAACxB,QAAD,EAAWC,UAAX,EAAuB,GAAGwB,IAA1B,CANM,CAAT;AAOH","names":["React","createContext","useContext","useRef","useCallback","useEffect","isFunction","useMap","NavigationTargetContext","register","deregister","NavigationTargetWrapper","isCurrent","isOverlayed","children","callbacks","fn","has","console","warn","set","undefined","cleanup","get","delete","value","current","forEach","_","cb","newCleanup","Provider","useOnCurrentTargetChange","callback","deps"],"sources":["../../src/components/NavigationTargetContext.tsx"],"sourcesContent":[null]},"metadata":{},"sourceType":"module"}