{"ast":null,"code":"// NOTE: This file is a copy of `framerjs/shared/src/assert.ts` this was done to\n// prevent pulling in files from outside library.\n\n/**\n * Throws an error when the condition is falsy, optionally pass in a message to\n * describe the error.\n *\n * Best to use asserts where data is about to be stored. Then errors are caught\n * early, close to the cause. Otherwise data with broken expectation might hang\n * around, only to cause errors when used later on, with no pointer back to what\n * caused that bad state.\n *\n * Note that when an assert fails, consider that a fatal error caused by buggy\n * code. The program should halt, or perhaps do some kind of high level\n * recovery, and the bug should be reported and fixed. Asserts are not well\n * suited to use as defensive programming, but are good to use to quickly\n * highlight mistakes while writing new code.\n *\n * Also note asserts should not have side effects, the program should continue\n * to work when asserts are compiled away. Because asserts might be compiled\n * away in production code.\n *\n * And finally, both the condition should be cheap, and the message should not\n * do string interpolation, instead you can pass in multiple parts of the\n * message.\n */\nexport function assert(condition) {\n  if (condition) return;\n\n  for (var _len = arguments.length, msg = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    msg[_key - 1] = arguments[_key];\n  }\n\n  const e = Error(\"Assertion Error\" + (msg.length > 0 ? \": \" + msg.join(\" \") : \"\")); // Hack the stack so the assert call itself disappears. Works in jest and in chrome.\n\n  if (e.stack) {\n    try {\n      const lines = e.stack.split(\"\\n\");\n\n      if (lines[1].includes(\"assert\")) {\n        lines.splice(1, 1);\n        e.stack = lines.join(\"\\n\");\n      } else if (lines[0].includes(\"assert\")) {\n        lines.splice(0, 1);\n        e.stack = lines.join(\"\\n\");\n      }\n    } catch {// nothing\n    }\n  }\n\n  throw e;\n}\n/**\n * Asserts that a code path is never entered. Additionally, asserts that the provided\n * value is evaluated to `never` by the type system, which means all possible discrete\n * types have been exhaustively checked by the time this statement is reached.\n */\n\nexport function assertNever(x, error) {\n  throw error || new Error(x ? `Unexpected value: ${x}` : \"Application entered invalid state\");\n}","map":{"version":3,"mappings":"AAAA;AACA;;AAEA;;;;;;;;;;;;;;;;;;;;;;;AAuBA,OAAM,SAAUA,MAAV,CAAiBC,SAAjB,EAA8C;AAChD,MAAIA,SAAJ,EAAe;;AADiC,oCAAVC,GAAU;AAAVA,OAAU;AAAA;;AAGhD,QAAMC,CAAC,GAAGC,KAAK,CAAC,qBAAqBF,GAAG,CAACG,MAAJ,GAAa,CAAb,GAAiB,OAAOH,GAAG,CAACI,IAAJ,CAAS,GAAT,CAAxB,GAAwC,EAA7D,CAAD,CAAf,CAHgD,CAIhD;;AACA,MAAIH,CAAC,CAACI,KAAN,EAAa;AACT,QAAI;AACA,YAAMC,KAAK,GAAGL,CAAC,CAACI,KAAF,CAAQE,KAAR,CAAc,IAAd,CAAd;;AACA,UAAID,KAAK,CAAC,CAAD,CAAL,CAASE,QAAT,CAAkB,QAAlB,CAAJ,EAAiC;AAC7BF,aAAK,CAACG,MAAN,CAAa,CAAb,EAAgB,CAAhB;AACAR,SAAC,CAACI,KAAF,GAAUC,KAAK,CAACF,IAAN,CAAW,IAAX,CAAV;AACH,OAHD,MAGO,IAAIE,KAAK,CAAC,CAAD,CAAL,CAASE,QAAT,CAAkB,QAAlB,CAAJ,EAAiC;AACpCF,aAAK,CAACG,MAAN,CAAa,CAAb,EAAgB,CAAhB;AACAR,SAAC,CAACI,KAAF,GAAUC,KAAK,CAACF,IAAN,CAAW,IAAX,CAAV;AACH;AACJ,KATD,CASE,MAAM,CACJ;AACH;AACJ;;AACD,QAAMH,CAAN;AACH;AAED;;;;;;AAKA,OAAM,SAAUS,WAAV,CAAsBC,CAAtB,EAAgCC,KAAhC,EAA2C;AAC7C,QAAMA,KAAK,IAAI,IAAIV,KAAJ,CAAUS,CAAC,GAAG,qBAAqBA,CAAC,EAAzB,GAA8B,mCAAzC,CAAf;AACH","names":["assert","condition","msg","e","Error","length","join","stack","lines","split","includes","splice","assertNever","x","error"],"sources":["../../src/utils/assert.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"module"}